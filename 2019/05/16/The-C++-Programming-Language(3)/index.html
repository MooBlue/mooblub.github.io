<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>对内存操作的考察GetMemory - Star</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/img/post_background.jpg"><div class="post-title"><h1 class="title">对内存操作的考察GetMemory</h1><ul class="meta"><li><i class="icon icon-author"></i>Lucifer</li><li><i class="icon icon-clock"></i>17 Minutes</li><li><i class="icon icon-calendar"></i>May 16, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><p>对内存操作的考查主要集中在：</p>
<p>（1）指针的理解；<br>（2）变量的生存期及作用范围；<br>（3）良好的动态内存申请和释放习惯。</p>
<p>题目1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char *p)</span><br><span class="line">&#123;</span><br><span class="line">	p = (char *)malloc(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	GetMemory(str); //GetMemory(&amp;str)编译出错，将一个指针地址值传递给一级指针。</span><br><span class="line">	strcpy(str, &quot;hello world&quot;);</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请问运行Test 函数会有什么样的结果？<br>分析：<br>程序崩溃。因为<code>GetMemory</code> 并不能传递动态内存，<code>Test</code>函数中的str一直都是<code>NULL</code>。<code>strcpy(str, &quot;hello world&quot;);</code>将使程序崩溃。<br>执行<code>GetMemory</code>之后，p得到新分配的空间地址，<code>str</code>依然为<code>NULL</code>；<br>没有对内存进行回收<code>free()</code>，局部变量存在栈区，<code>malloc()</code>在堆区；局部变量在函数执行完毕之后回收栈空间；</p>
<p>new的时候有可能内存出错，应该在<em>p = (char </em>) malloc( num ); 后判断内存是否申请成功，应加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ( *p == NULL )</span><br><span class="line">&#123;</span><br><span class="line">　    ...//进行申请内存失败处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动态创建的内存没释放。<br>错误分析：<br>错认为 GetMemory(char   *p)中的 p “就是” GetMemory(str)中的str。但p“不是”str，它只是“等于”str 。<br>就象：<br>int   a   =   100；<br>int   b   =   a；       //   现在b等于a<br>b   =   500；         //   现在能认为a   =   500 ?<br>显然不能认为a   =   500，因为b只是等于a，但不是a！ 当b改变的时候，a并不会改变，b就不等于a了。    因此，虽然p已经有new的内存，但str仍然是null<br>str没有得到分配内存的地址值。<br>内存空间状态：首先申请了四个字节的栈空间，存放str指针，此时str的值为0，存放str的这块内存的地址值为0x0012ff7c。调用函数 GetMemory，指针P入栈，也分配了四个字节的栈空间，P被赋str的值即此时P的值也为0，存放指针P的内存地址是0x0012ff2c。然后将新开辟的100个字节的内存空间地址赋给P，此时P的值为0x00372b70。函数调用结束时str的值仍为0，str并没有得到那块100个字节的内存空间地址值！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetMemory(str);             //把str传进去，str是一个指针，而他实际上是一个int      </span><br><span class="line">void   GetMemory(char   *p)     //   p是str的一个副本   </span><br><span class="line">&#123;   </span><br><span class="line">p=(char   *)new   char[100];         //   p的值改变，但是str的值并没有改变。   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而双重指针为什么就可以了呢：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetMemory(&amp;str);             //把str的地址传进去       </span><br><span class="line">void   GetMemory(char   **   p)     //   p是str地址的一个副本   </span><br><span class="line">&#123;  </span><br><span class="line">    *p   =   (char   *)new   char[100];         //   p指向的值改变，也就是str的值改变。   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>str可以得到分配内存的地址值。<br>内存空间状态：首先申请了四个字节的栈空间，存放str指针，此时str的值为0，存放str的这块内存的地址值为0x0012ff7c。调用函数 GetMemory，指针P入栈，也分配了四个字节的栈空间，此时P是一个二级指针，存放了指针str的地址值，即P的值是0x0012ff7c，存放指针P的内存空间的地址值是0x0012ff2c。然后将新开辟的100个字节的内存空间地址值0x00372b70赋给*P，即str，所以str的值为 0x00372b70。函数返回时str的值为分配的100个字节的内存空间的地址！</p>
<p>修改方法1：(推荐使用这种方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory2(char **p)变为二级指针. </span><br><span class="line">void GetMemory2(char **p, int num) </span><br><span class="line">&#123; </span><br><span class="line">*p = (char *)malloc(sizeof(char) * num); </span><br><span class="line">&#125; </span><br><span class="line">void Test(void)</span><br><span class="line">&#123; </span><br><span class="line">char *str=NULL; </span><br><span class="line">GetMemory=(&amp;str); </span><br><span class="line">strcpy(str,&quot;hello world&quot;); </span><br><span class="line">printf(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory()</span><br><span class="line">&#123; </span><br><span class="line">char *p=(char *)malloc(100); </span><br><span class="line">return p; </span><br><span class="line">&#125; </span><br><span class="line">void Test(void)&#123; </span><br><span class="line">char *str=NULL; </span><br><span class="line">str=GetMemory()；</span><br><span class="line">strcpy(str,&quot;hello world&quot;); </span><br><span class="line">printf(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>题目2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory(void)</span><br><span class="line">&#123;</span><br><span class="line">	char p[] = &quot;hello world&quot;;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	str = GetMemory();</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请问运行Test 函数会有什么样的结果？<br>分析：<br>可能是乱码。因为<code>GetMemory</code>返回的是指向“栈内存”的指针，该指针的地址不是<code>NULL</code>，但其原来的内容已经被清除，新内容不可知。<br>打印内容未知；p指向“栈内存”；调用<code>GetMemory()</code>之后栈内存释放，但str仍指向栈区地址，造成内存泄露，该栈区可能用作其他用途，存储其他内容。因此打印内容未知。</p>
<p>题目3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char **p, int num)</span><br><span class="line">&#123;</span><br><span class="line">	*p = (char *)malloc(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	GetMemory(&amp;str, 100);</span><br><span class="line">	strcpy(str, &quot;hello&quot;);</span><br><span class="line">	printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请问运行Test 函数会有什么样的结果？<br>分析：<br>（1）能够输出hello<br>（2）内存泄漏<br>将动态分配的内存的指针赋值给str指针；但GetMemory()函数中未检查分配失败的情况；<code>if(*p==NULL){};</code><br>没有对分配的内存进行回收free()；</p>
<p>题目4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = (char *) malloc(100);</span><br><span class="line">	strcpy(str, “hello”);</span><br><span class="line">	free(str);</span><br><span class="line"> if(str != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">	strcpy(str, “world”);</span><br><span class="line">	printf(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请问运行Test 函数会有什么样的结果？<br>分析：<br>篡改动态内存区的内容，后果难以预料，非常危险。<br>因为free(str);之后，str 成为野指针，if(str != NULL)语句不起作用。<br>应在free(str)之后将str赋值为空 str=NULL;</p>
<p>正确写法的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char *GetMemory(char *&amp;p, int num)</span><br><span class="line">&#123;</span><br><span class="line">	p = (char *)malloc(sizeof(char)*num);</span><br><span class="line">	//p = new char[num];</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char *str ;</span><br><span class="line">GetMemory(str, 100);</span><br><span class="line">strcpy(str, &quot;hello&quot;);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//上面是一个正确的程序，下面是转载的一些相关的知识</p>
<hr>
<p>GetMemory错误讲解（指针练习） 错误程序：<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<p>附录A（相关资料）</p>
<p>试题5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory( void )</span><br><span class="line">&#123; </span><br><span class="line">	char p[] = &quot;hello world&quot;; </span><br><span class="line">	return p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test( void )</span><br><span class="line">&#123; </span><br><span class="line">	char *str = NULL; </span><br><span class="line">	str = GetMemory(); </span><br><span class="line">	printf( str ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>试题6：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory( char **p, int num )</span><br><span class="line">&#123;</span><br><span class="line">	*p = (char *) malloc( num );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test( void )</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	GetMemory( &amp;str, 100 );</span><br><span class="line">	strcpy( str, &quot;hello&quot; ); </span><br><span class="line">	printf( str ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>试题7：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Test( void )</span><br><span class="line">&#123;</span><br><span class="line">　char *str = (char *) malloc( 100 );</span><br><span class="line">　strcpy( str, &quot;hello&quot; );</span><br><span class="line">　free( str ); </span><br><span class="line">　... //省略的其它语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解答：</p>
<p>试题5中<br>char p[] = “hello world”;<br>return p;<br>的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。</p>
<p>试题6中<br>1、GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句<br><em>p = (char </em>) malloc( num );<br>后未判断内存是否申请成功，应加上：<br>if ( <em>p == NULL )<br>{<br>　…//进行申请内存失败处理<br>}<br>2、试题6的Test函数中也未对malloc的内存进行释放。<br>试题7中<br>存在与试题6同样的问题，在执行char </em>str = (char *) malloc(100); 后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上： str = NULL; 打印未知。<br>剖析：<br>　　试题4～7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60的错误。但是要完全解答正确，却也绝非易事。</p>
<p>　　再看看下面的一段程序有什么错误：<br>swap( int<em> p1,int</em> p2 )<br>{<br>　int <em>p;
　</em>p = <em>p1;
　</em>p1 = <em>p2;
　</em>p2 = <em>p;<br>}<br>　　在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：<br>swap( int</em> p1,int<em> p2 )<br>{<br>　int p;<br>　p = </em>p1;<br>　<em>p1 = </em>p2;<br>　*p2 = p;<br>}</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">4</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjw1v7udi000cgoxmu3kw6nww" data-title="对内存操作的考察GetMemory" data-url="http://yoursite.com/2019/05/16/The-C++-Programming-Language(3)/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/05/21/The-C++-Programming-Language(5)/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/05/16/The-C++-Programming-Language(2)/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/MooBlue" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Star<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>