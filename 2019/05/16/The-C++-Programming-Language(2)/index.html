<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>堆、栈间的比较 - Star</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/img/post_background.jpg"><div class="post-title"><h1 class="title">堆、栈间的比较</h1><ul class="meta"><li><i class="icon icon-author"></i>Lucifer</li><li><i class="icon icon-clock"></i>5 Minutes</li><li><i class="icon icon-calendar"></i>May 16, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="1、内存分配方面："><a href="#1、内存分配方面：" class="headerlink" title="1、内存分配方面："></a>1、内存分配方面：</h3><p>堆（heap） ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。new、malloc、delete、free等等。<br>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。</p>
<h3 id="2、申请方式方面："><a href="#2、申请方式方面：" class="headerlink" title="2、申请方式方面："></a>2、申请方式方面：</h3><p>堆（heap） ：需要程序员自己申请，并指明大小。<br>例如，在c中malloc函数如<code>p1 = (char *)malloc(10)；</code> 但是注意p1、本身是在栈中的,因为他们还是可以认为是局部变量。<br>例如，在C++中用new运算符<br>栈（stack）：由系统自动分配。<br>例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。</p>
<h3 id="3、系统响应方面："><a href="#3、系统响应方面：" class="headerlink" title="3、系统响应方面："></a>3、系统响应方面：</h3><p>堆（heap） ：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br>栈（stack）：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<h3 id="4、大小限制方面："><a href="#4、大小限制方面：" class="headerlink" title="4、大小限制方面："></a>4、大小限制方面：</h3><p>堆（heap） ：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>栈（stack）：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
<h3 id="5、效率方面："><a href="#5、效率方面：" class="headerlink" title="5、效率方面："></a>5、效率方面：</h3><p>堆（heap） ：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。<br>栈（stack）：由系统自动分配，速度较快。但程序员是无法控制的。</p>
<h3 id="6、存放内容方面："><a href="#6、存放内容方面：" class="headerlink" title="6、存放内容方面："></a>6、存放内容方面：</h3><p>堆（heap） ：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br>栈（stack）：在函数调用时第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<h3 id="7、存取效率方面："><a href="#7、存取效率方面：" class="headerlink" title="7、存取效率方面："></a>7、存取效率方面：</h3><p><code>char s1[] = &quot;aaa&quot;;</code> aaa是在运行时刻赋值的；<br><code>char *s2 = &quot;bbb&quot;;</code>  bbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char a = 1;</span><br><span class="line">char c[] = &quot;1234567890&quot;;</span><br><span class="line">char *p =&quot;1234567890&quot;;</span><br><span class="line">a = c[1];</span><br><span class="line">a = p[1];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10: a = c[1];</span><br><span class="line">00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]</span><br><span class="line">0040106A 88 4D FC mov byte ptr [ebp-4],cl</span><br><span class="line">11: a = p[1];</span><br><span class="line">0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</span><br><span class="line">00401070 8A 42 01 mov al,byte ptr [edx+1]</span><br><span class="line">00401073 88 45 FC mov byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure></p>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p>
<h3 id="归纳："><a href="#归纳：" class="headerlink" title="归纳："></a>归纳：</h3><p>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>1.程序的运行场所是内存，栈和堆是进程的虚拟内存中的两部分区域。<br>当程序被执行时，程序代码，你所创建的变量、常量等都会被压入栈空间里，栈是程序代码的执行区域。栈的内存地址是连续的且被一一记录，所以说当你创建了一个变量(比如int var = 1)，我们就可以通过var这个变量来访问变量的内容。在这里，var就存放在栈中，它的地址已经默认被编译器计算好了，调用过程也不需要你涉及到有关地址的操作。更直观的感受是数组，数组里的元素在栈里面是连续排放的，相邻两个元素的地址相差1。<br>而堆是不同于栈的另一部分区域，系统会给每个程序分配一部分栈空间让他们能够运行起来，问题就是栈空间必然存在不够用的问题，而堆不属于程序，堆是独立的，是公用的。只要你malloc(sizeof(SIZE_YOU_WANT))，就可以得到相应一部分的堆空间。</p>
<p>2.有栈，为什么用堆？<br>栈里面的东西有生命周期，说俗点就是变量作用域，你在函数内部创建一个变量，函数调用结束这个变量就没了。而堆里面的东西独立于你的程序，malloc()之后，除非你free()掉，否则一直存在。</p>
<p>3.为什么用堆少？<br>麻烦！</p>
<p>4.有什么要注意？<br>堆里面申请的东西，是随机分配的，不像栈里面的地址都已经计算好了。所以申请了堆空间之后一定要创建一个指针保存你说申请到的堆空间的地址。不然就找不到你申请的空间了。既然涉及到指针，请注意用之前检查一下指针空不空的问题。堆空间的东西申请好，在用完之后一定要free()掉，以防止堆溢出。</p>
<p>5、进程、线程与堆、栈<br>现在是多任务系统。每个进程是资源（不含处理器资源）分配的基本单位。每个进程含若干线程。线程是调度执行的基本单位。同一个进程的多个线程可以共享所属进程的资源。程序员可以进行同步控制（多线程编程）。每个进程有一个或几个堆。这要看不同的OS了。程序员要在堆中分配/释放空间，需要malloc/free这样的显式操作。每个线程有一个私有资源，那就是栈。函数调用时，要把返回地址和参数入栈。被调函数执行时，要把参数取出来，赋给形参。被调函数执行完后还要把返回地址取出来，跳回去。栈是自动实现的，不需要程序员干预。（因为编译器实现了）。局部变量也位于栈。</p>
<p>6、内存管理分页机制<br>Windows / Linux采用段页式。但这只是内存管理方法。跟堆栈是两回事啊。并不矛盾。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">6</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjw1tqqte0003xoxmvnuzwd6y" data-title="堆、栈间的比较" data-url="http://yoursite.com/2019/05/16/The-C++-Programming-Language(2)/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/05/16/The-C++-Programming-Language(3)/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/05/16/The-C++-Programming-Language(1)/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/MooBlue" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Star<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>