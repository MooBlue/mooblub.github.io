<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>C++面试题基础理论知识（二） - Star</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/img/post_background.jpg"><div class="post-title"><h1 class="title">C++面试题基础理论知识（二）</h1><ul class="meta"><li><i class="icon icon-author"></i>Lucifer</li><li><i class="icon icon-clock"></i>9 Minutes</li><li><i class="icon icon-calendar"></i>January 26, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="基础理论知识"><a href="#基础理论知识" class="headerlink" title="基础理论知识"></a>基础理论知识</h2><h3 id="1-new-delete-与-malloc-free-的区别"><a href="#1-new-delete-与-malloc-free-的区别" class="headerlink" title="1. new / delete 与 malloc / free 的区别"></a>1. new / delete 与 malloc / free 的区别</h3><p>malloc / free 是库函数，new / delete 是 C++ 运算符。对于非内部数据类型而言，光用 malloc / free 无法满足动态对象的要求。 new / delete 是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是 malloc / free 是库函数，不会执行构造/析构。</p>
<p>备注： 运算符是语言自身的特性，有固定的语义，编译器知道意味着什么，由编译器解释语义，生成相应的代码。库函数是依赖于库的，一定程度上是独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。实际中，一些高级点的编译器，都会对库函数进行特别处理。</p>
<h3 id="2-delete-与-delete-区别"><a href="#2-delete-与-delete-区别" class="headerlink" title="2. delete 与 delete[] 区别"></a>2. delete 与 delete[] 区别</h3><p>delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。<br>delete 与 new 配套使用； delete[] 与 new[] 配套使用。<br>对于内建的简单数据类型， delete 和 delete[] 功能相同。<br>对于复杂数据类型， delete 和 delete[] 不同，前者删除单个对象，后者删除数组。</p>
<h3 id="3-子类析构时，要调用父类的析构函数吗？"><a href="#3-子类析构时，要调用父类的析构函数吗？" class="headerlink" title="3. 子类析构时，要调用父类的析构函数吗？"></a>3. 子类析构时，要调用父类的析构函数吗？</h3><p>析构函数调用的次序是先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是 virtual 的， 否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。</p>
<p>备注： 不用显示调用，自动调用。</p>
<h3 id="4-多态、虚函数、纯虚函数"><a href="#4-多态、虚函数、纯虚函数" class="headerlink" title="4. 多态、虚函数、纯虚函数"></a>4. 多态、虚函数、纯虚函数</h3><p>多态： 不同对象接收相同的消息产生不同的动作。   多态包括 编译时多态 和 运行时多态。<br>    运行时多态是： 通过继承和虚函数来体现的。<br>    编译时多态： 运算符重载上。</p>
<p>虚函数： 在基类中用 virtual 的成员函数。允许在派生类中对基类的虚函数重新定义。<br>    基类的虚函数可以有函数体，基类也可以实例化。<br>    虚函数要有函数体，否则编译无法通过。<br>    虚函数在子类中可以不覆盖。<br>    构造函数不能是虚函数。</p>
<p>纯虚函数： 基类中为其派生类保留一个名字，以便派生类根据需要进行定义。<br>    包含一个纯虚函数的类是抽象类。<br>    纯虚函数后面有 = 0 ;<br>    抽象类不可以实例化。但可以定义指针。<br>    如果派生类不是先基类的纯虚函数，则仍然是抽象类。<br>     抽象类可以包含虚函数。</p>
<h3 id="5-抽象类和接口的区别"><a href="#5-抽象类和接口的区别" class="headerlink" title="5. 抽象类和接口的区别"></a>5. 抽象类和接口的区别</h3><p>在C++里面抽象类就是接口</p>
<p>抽象类：定义了纯虚函数的类是抽象类，不能实例化。<br>抽象类包括抽象方法（纯虚方法），也可以包含普通方法。<br>抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖。<br>虽不能定义抽象类的实例，但是可以定义抽象类的指针。</p>
<h3 id="6-将引用作为函数参数有哪些特点"><a href="#6-将引用作为函数参数有哪些特点" class="headerlink" title="6. 将引用作为函数参数有哪些特点"></a>6. 将引用作为函数参数有哪些特点</h3><ol>
<li>与指针调用效果一样</li>
<li>引用传参，内存中并没有产生副本。</li>
<li>用指针传递，也要给形参分配存储单元；并且需要使用“* 变量”的形式，可读性差；另外，调用的地方还得用地址作为实参。</li>
</ol>
<h3 id="7-什么时候用常引用"><a href="#7-什么时候用常引用" class="headerlink" title="7. 什么时候用常引用"></a>7. 什么时候用常引用</h3><p>const int &amp;ra = a; //不能通过引用对目标变量的值进行修改，从而使引用的目标成为const的，安全。<br>void bar(String &amp;ra)<br>bar(“AA”) //这个会报错，因为”AA”相当于 const char[]， 不能传递bar函数。<br>可以把函数声明为 void bar(Const String &amp;ra)， 上述语句就不会报错。</p>
<h3 id="8-引用作为函数返回值类型的格式，好处和规则？"><a href="#8-引用作为函数返回值类型的格式，好处和规则？" class="headerlink" title="8. 引用作为函数返回值类型的格式，好处和规则？"></a>8. 引用作为函数返回值类型的格式，好处和规则？</h3><p>int &amp;fun(int a) {}    好处，不会生成副本。<br>规则： 不能返回局部变量的引用；不能返回函数内部 new 分配的内存引用；如果返回成员的话，返回 const 。</p>
<h3 id="9-结构与联合的区别"><a href="#9-结构与联合的区别" class="headerlink" title="9. 结构与联合的区别"></a>9. 结构与联合的区别</h3><p>联合是公用存储单元的，任何一个时刻只有一个被选中的成员。一旦赋值后，其他成员也覆盖了。</p>
<h3 id="10-重载-overload-和重写-override"><a href="#10-重载-overload-和重写-override" class="headerlink" title="10. 重载(overload) 和重写(override)?"></a>10. 重载(overload) 和重写(override)?</h3><p>重载： 多个同名函数，参数不同(个数不同，参数类型不同)；是同一层级的函数；静态绑定；编译期绑定。<br>重写： 子类重新定义父类函数的方法；是动态绑定。</p>
<h3 id="11-有几种情况用-intialization-list-初始化列表-而不是-assignment-赋值-？"><a href="#11-有几种情况用-intialization-list-初始化列表-而不是-assignment-赋值-？" class="headerlink" title="11. 有几种情况用 intialization list (初始化列表) 而不是 assignment (赋值) ？"></a>11. 有几种情况用 intialization list (初始化列表) 而不是 assignment (赋值) ？</h3><p>当类中含有 const 成员变量； reference 成员变量； 基类构造函数需要初始化列表。</p>
<h3 id="12-C-是不是类型安全的？"><a href="#12-C-是不是类型安全的？" class="headerlink" title="12. C++ 是不是类型安全的？"></a>12. C++ 是不是类型安全的？</h3><p>不是；两个不同类型的指针之间可以强制转换。</p>
<h3 id="13-main-函数之前会执行什么代码？"><a href="#13-main-函数之前会执行什么代码？" class="headerlink" title="13. main 函数之前会执行什么代码？"></a>13. main 函数之前会执行什么代码？</h3><p>全局变量的初始化。</p>
<h3 id="14-内存分配方式和区别"><a href="#14-内存分配方式和区别" class="headerlink" title="14. 内存分配方式和区别"></a>14. 内存分配方式和区别</h3><ol>
<li>静态存储区： 在编译时就分配好，在整个运行期间都存在。比如全局变量， static 变量。</li>
<li>常量区： 存放常量的，比如字符串常量。</li>
<li>堆。</li>
<li>栈。</li>
</ol>
<h3 id="15-const-与-define-相比，优点？"><a href="#15-const-与-define-相比，优点？" class="headerlink" title="15. const 与 #define 相比，优点？"></a>15. const 与 #define 相比，优点？</h3><p>const: 定义常量；修饰函数参数；修饰函数返回值；修饰类成员函数。</p>
<p>好处: const 修饰的有数据类型，而宏没有，所以可以做类型检查；而宏仅作字符替换，无安全检查。<br>const常量可以调试；宏不加括号的话有副作用。</p>
<h3 id="16-为什么基类的析构函数是虚函数？"><a href="#16-为什么基类的析构函数是虚函数？" class="headerlink" title="16. 为什么基类的析构函数是虚函数？"></a>16. 为什么基类的析构函数是虚函数？</h3><p>动态绑定，不会造成潜在的内存泄漏</p>
<h3 id="17-全局变量和局部变量的区别？-如何实现的？-操作系统和编译器是怎么知道的？"><a href="#17-全局变量和局部变量的区别？-如何实现的？-操作系统和编译器是怎么知道的？" class="headerlink" title="17. 全局变量和局部变量的区别？ 如何实现的？ 操作系统和编译器是怎么知道的？"></a>17. 全局变量和局部变量的区别？ 如何实现的？ 操作系统和编译器是怎么知道的？</h3><p>全局变量分配在全局数据段(静态存储区)，在程序开始运行时候加载。局部变量则分配在堆栈里面。</p>
<h3 id="18-引用于指针的区别"><a href="#18-引用于指针的区别" class="headerlink" title="18. 引用于指针的区别"></a>18. 引用于指针的区别</h3><p>引用必须初始化，指针不用。<br>引用初始化后不能改变，指针可以改变所指的内容。<br>不存在指向空值的引用，但是存在指向空值的指针。<br>指针可以有多级；引用就一级。<br>指针要解引用，引用不用。<br>引用没有 const， 但是指针有。<br>sizeof 结果不同。<br>自增的语义不同。</p>
<h3 id="19-int-id-sizeof-unsigned-long-合法吗？"><a href="#19-int-id-sizeof-unsigned-long-合法吗？" class="headerlink" title="19. int id [sizeof(unsigned long)]合法吗？"></a>19. int id [sizeof(unsigned long)]合法吗？</h3><p>合法；数组的大小在编译的时候就要确认。</p>
<h3 id="20-虚函数与纯虚函数"><a href="#20-虚函数与纯虚函数" class="headerlink" title="20. 虚函数与纯虚函数"></a>20. 虚函数与纯虚函数</h3><p>虚函数为了重载和多态，在基类中是有定义的，即便定义为空。在子类中可以重写。<br>纯虚函数在基类中没有定义，必须在子类中实现。<br>多态的基础是继承，需要虚函数的支持。</p>
<h3 id="21-子类不能继承父类的函数"><a href="#21-子类不能继承父类的函数" class="headerlink" title="21. 子类不能继承父类的函数"></a>21. 子类不能继承父类的函数</h3><p>子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数。</p>
<h3 id="22-开发中常用的数据结构："><a href="#22-开发中常用的数据结构：" class="headerlink" title="22. 开发中常用的数据结构："></a>22. 开发中常用的数据结构：</h3><p>A：数组和链表：<br>数组大小不能动态定义。链表和动态分配大小的。<br>数组不适应动态增/减的情况，因为大小固定，一旦定义就不能改变。<br>链表适合动态的增加、删除数据。<br>数组的随机访问快。<br>数组栈中分配； 链表在堆中。<br>　　<br>B：二叉树遍历：<br>先序、中序、后序</p>
<h3 id="23-const-与-static-的用法"><a href="#23-const-与-static-的用法" class="headerlink" title="23.  const 与 static 的用法"></a>23.  const 与 static 的用法</h3><p>const：<br>修饰类成员变量，成员不可以改。<br>修饰函数参数；<br>修饰返回值；<br>修饰函数，函数不会修改类内的数据成员。不会调用非const成员函数。（在函数末尾，默认是const this指针，不能修改成员）<br>const函数只能调用const函数，非const函数可以调用const函数。<br>　<br>static：<br>局部static变量：局部静态变量，处于内存中的静态存储区；只能初始化一次；作用域是局部。<br>全局static变量：全局静态变量，静态存储区；全局静态变量的作用局是声明它的文件，在文件之外是不可见的。其实是从<br>定义的地方到文件结尾。</p>
<p>　<br>类的static成员：类的全局变量，被类的所有独享共享，包括派生类的对象。按照这种方式int base::var = 10;进行<br>初始化，不能在构造函数内初始化，但是可以用const修饰的static数据成员在类内初始化。</p>
<p>static修饰成员函数，类只有一份，不含this指针。<br>static成员变量定义放在cpp文件中。 const static 可以就地初始化</p>
<h3 id="类的-static-变量在什么时候初始化，函数的-static-变量什么时候初始化？"><a href="#类的-static-变量在什么时候初始化，函数的-static-变量什么时候初始化？" class="headerlink" title="类的 static 变量在什么时候初始化，函数的 static 变量什么时候初始化？"></a>类的 static 变量在什么时候初始化，函数的 static 变量什么时候初始化？</h3><p>类的静态成员在类实例化之前就存在了；函数的 static 变量在执行此函数时进行实例化 (第一次调用的时候，只初始化一次)</p>
<h3 id="栈溢出的原因"><a href="#栈溢出的原因" class="headerlink" title="栈溢出的原因"></a>栈溢出的原因</h3><p>栈大小有限制；分过多的数组；<br>递归调用层太深；</p>
<h3 id="频繁出现的短小函数，在-c-c-中分别如何实现"><a href="#频繁出现的短小函数，在-c-c-中分别如何实现" class="headerlink" title="频繁出现的短小函数，在 c/c++ 中分别如何实现"></a>频繁出现的短小函数，在 c/c++ 中分别如何实现</h3><p>C 中用宏定义； C++ 内联</p>
<h3 id="C-函数传参数方式"><a href="#C-函数传参数方式" class="headerlink" title="C++ 函数传参数方式"></a>C++ 函数传参数方式</h3><p>值传递、指针、引用</p>
<h3 id="定义宏注意什么？"><a href="#定义宏注意什么？" class="headerlink" title="定义宏注意什么？"></a>定义宏注意什么？</h3><p>定义部分的每个形参和整个表达式都必须用括号括起来。</p>
<h3 id="h-头文件中的-ifndef-define-endif-作用"><a href="#h-头文件中的-ifndef-define-endif-作用" class="headerlink" title=".h 头文件中的 ifndef/define/endif 作用"></a>.h 头文件中的 ifndef/define/endif 作用</h3><p>防止头文件重复包含</p>
<h3 id="struct-与-class-比较"><a href="#struct-与-class-比较" class="headerlink" title="struct 与 class 比较"></a>struct 与 class 比较</h3><p>struct 的成员默认是共有的，而类的成员默认是私有的。<br>继承的时候， class 默认是私有继承；结构体是共有继承。<br>class 还用于定义模板参数，就像 typename</p>
<h3 id="系统会自动打开和关闭的三个标准文件是？"><a href="#系统会自动打开和关闭的三个标准文件是？" class="headerlink" title="系统会自动打开和关闭的三个标准文件是？"></a>系统会自动打开和关闭的三个标准文件是？</h3><p>在C语言中，在程序开始运行时，系统自动打开3个标准文件：标准输入、标准输出、标准出错输出。<br>通常这3个文件都与终端相联系。因此，以前我们所用到的从终端输入或输出都不需要打开终端文件。系统自定义了3个文件指针 stdin、stdout、stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。</p>
<p>标准输入流：stdin<br>标准输出流：stdout<br>标准错误输出流：stderr</p>
<h3 id="防止指针越界和内存泄漏的方法"><a href="#防止指针越界和内存泄漏的方法" class="headerlink" title="防止指针越界和内存泄漏的方法"></a>防止指针越界和内存泄漏的方法</h3></div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-面试/">C++面试</a><span class="tag-list-count">3</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjw1tjs7v000lq4xmkeku86pg" data-title="C++面试题基础理论知识（二）" data-url="http://yoursite.com/2019/01/26/C++-case-interview2/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/01/26/C++-case-interview3/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/01/26/C++-case-interview1/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/MooBlue" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Star<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>